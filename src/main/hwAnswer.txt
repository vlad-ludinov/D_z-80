Вопросы:

1) Почему использование тестовых
заглушек может быть полезным
при написании модульных тестов?

2) Какой тип тестовой заглушки следует
использовать, если вам нужно проверить,
что метод был вызван с определенными аргументами?

3) Какой тип тестовой заглушки следует
использовать, если вам просто нужно вернуть
определенное значение или исключение
в ответ на вызов метода?

4) Какой тип тестовой заглушки вы бы
использовали для имитации  взаимодействия
с внешним API или базой данных?

Ответы:

1) Тестовые заглушки позволяют изолировать
тестируемый модуль от внешних зависимостей,
а кроме этого использование тестовых заглушек
позволяет явно управлять входными данными
и результатами модуля.

// ответы на вопросы 2-4 взяты не из головы,
// а просто из конспекта лекции, который находится
// в приложенных файлах к уроку

2) Spy (шпионы) — это заглушки, которые также
записывают некоторую информацию,
основанную на том, как они были вызваны.
Test spy (тестовый шпион) используется
для тестов взаимодействия. Основная
функция — запись данных и вызовов,
поступающих из тестируемого объекта, для
последующей проверки корректности
вызова зависимого объекта. Он позволяет
проверить логику именно нашего тестируемого
объекта без проверок зависимых объектов.

3) Stub (заглушки) — предоставляют готовые ответы на
наши вызовы, в них нет логики, но они возвращают
предопределённое значение. Это готовые ответы на
вызовы, сделанные во время теста, обычно вообще
не реагируя ни на что, кроме того, что запрограммировано
для теста. Такие заглушки позволяют тесту
управлять опосредованным вводом тестируемой
системы и провоцировать выполнение ветвей кода,
которые в других условиях не выполняются.

4) Fake (подделка) — это тестовая заглушка,
задача которой очень похожа на стаб:
предоставить простые и быстрые ответы
клиенту, который его потребляет.
Fake используется, чтобы запускать тесты быстрее.
Это замена тяжеловесного внешнего зависимого
объекта легковесной реализацией.
Примером может быть реализация объекта доступа
к данным или репозитория в памяти. Эта поддельная
реализация сервиса авторизации не будет задействовать
базу данных, но будет использовать простую
коллекцию для хранения данных. Это позволяет нам
проводить интеграционное тестирование сервисов без
запуска базы данных и выполнения трудоёмких запросов.

